# Readme of Toy Framework
- @Auther Hwi Jun KIM. euler.bonjour@gmail.com
- See License.txt for license of this code.

- Code: https://github.com/khj1977/toy_framework/
- English ver: https://github.com/khj1977/toy_framework/blob/master/README_EN.md

- 氏名：金 輝俊 / Hwi Jun KIM
- Email: euler.bonjour@gmail.com
- 作成日付: 2017/5/15（2017/7/14追記）（2018/11 - 追記）

# Preliminary
- Aim: 従業員、経営幹部双方にとって良い労働環境を作り出す事
- Objective: オペレーション用ビジネスアプリケーションフレームワークの開発

## 序説及び、注釈

## どういったフレームワークなのか？なぜ、こういった設計なのか？どういう問題意識なのか？

簡単に言ってしまうと、初期の本プログラムは基本的にクイックハックであり、あまり完成度は高くない。しかし、ある程度、アプリケーションをいかにpluggableに作るか、という考えの一旦が見えるのではないか、と思い公開した。

その後、コードを積み増し、オペレーション最適化及び、税と社会保障、所得の再分配のシステムを念頭においたフルスタックのWebアプリケーションフレーワークを開発することを目的とすることにした。当然、コードの完成度は高める。

PHP用ならば、CakePHPやFuelなど既存のフレームワークがあるが、オペレーション最適化には新型のフレームワークが必要だと思い、開発している。

詳細はのちに書くが、簡単に言ってしまうとオペレーション最適化をかけると労働時間が減り、現政権の働き方改革にそった形になると思われる。リモートワークも働き方改革の一つの案であるかもしれないが、それはすでに既存のITや法制度の元、行えることであって、それだけでは生ぬるいと考える。もっとラディカルに労働時間をまず、残業なしの8時間で有給を好きに取れるように、次に給料を据え置いた上で、労働時間を6 - 7時間に抑えられないかと考える。

また、フレームワーク自体は例えばJavaで書かれたシステムとC#で書かれたシステムをつないだり、micro serviceを意識したシステムとなっている。アプリケーションよりに書くと省庁間の連携システムも平易に記述できることを念頭に設計されている。なぜ、そうするかと言うと、オペレーション最適化に加えて、税と社会保障、所得の再分配のシステム化を念頭に置いているからである（注：筆者は所得の再分配に負の所得税を念頭においている。負の所得税の財源は消費税だと仮定している。詳しくは別ドキュメントの「消費税のパラドックスと負の所得税」を参照の事）。

そもそも、Scaffoldなど開発効率を高めるための工夫をなぜ入れたかは以下の2つのドキュメントで解説している。

1. 以下のドキュメントの「プログラマ、Systems Architect or Project Manager（コンサル/SI or 事業会社IT部門）」の項目を参照の事：

経歴書 (Curriculum Vitae)
https://docs.google.com/document/d/1czBVntPBhOBG9KUvkWADlS716BDI92I_lu2ll0eFWj4/edit

2. なぜ、1. 戦略コンサルタント、2. ITコンサルタント、3. SIのプロジェクトマネージャー / アーキテクト、あるいは4. 事業会社のIT部門か？
https://docs.google.com/document/d/1zWH0Isx0HKe0wD5xfrzrBgrfUrRc8PdMjBlNlsV93kc/edit

そもそも、ある会社に対する提出物としてはじまった本プログラム群であるが（当時要求されていたプログラムはフレームワークではない。もっと単純なプログラムであった）、当時考えていた妄想を全てぶちこみ、オペレーション用及び、税と社会保障、所得の再分配のシステム用のフレームワークを目指す事にした。

他のドキュメントにも記述しているかもしれないが、Model/Controllerの背後には業務、業務プロセスが存在する。従って、ビジネス・アプリケーションを開発するときには業務や業務プロセス、業務フローに注目すべきであり、コードあるいはModelやControllerはあくまでも、システム化された結果にすぎないと考える。例えば業務最適化を最もしたいこと、あるいはすることにすると、いかに速くシステムを構築し、業務を表すシステムとするべきかが重要となってくる。したがって、Scallafoldなど、開発効率を高める工夫を入れた。

以下に上記ドキュメントと重なるが、改めてこのフレームワークの設計思想を明記する。端的に言ってしまえば、このフレームワークはオペレーション最適化 / 日本の労働環境の改善 (特に女性の労働環境の改善) / 税と社会保障、と所得の再分配 / を目的としたアプリケーションフレームワークである。

## なぜ、Scaffoldなのか？
なぜ、Scaffoldなのであろうか？業務システムでは画面はよくあるECやSNSのシステムのように派手にはならない。しかし、いわゆるWeb系システムの管理画面に近くなる。業務が多岐に渡ると画面数が増えたり、頻繁なロジックのアップデートのたびに画面を作り変えなければならない。Webシステムの管理画面のコーディングは一般的に退屈で、冗長となり、ミスも多くなる。したがって、単なるCRUDならば、自動生成してしまえばいい、という考え方のもと、Scaffoldを取り入れる。

全てをScaffoldにするつもりはなく、60%くらいがScaffoldでカバーできればいいと考えている。また、Composite View Pattternを取り入れ、Viewの高速開発もできるように考慮している設計である。

## Restful Object、micro serviceと有機的なシステム変更
また、業務システムを有機的に成長させ、仕様変更にロバストにするために、RESTfulな考え方を取り入れている。例えば、Javaで書いたシステムとPHPで書いた小さいシステムを組み合わせて使えるように、RESTDelegateやREST API呼び出しを多用する。Modelの内部でもO/R Mapperのプロパティアクセス（hook_.*）の中にREST API呼び出しをすれば、他の言語で書いたシステムとも連携可能となる。こうすることによって、例えば、厚生労働省のシステム（System H）がOR Mapperのプロパティアクセス（O/R Mapperのhook -function hook_xxx-）と連携するREST API呼び出しで年齢データをマイナンバーのシステム（System M）から呼び出すことができる。このように、ユーザーアプリケーションから見たら、OR Mapperへのアクセスとなり、自然な記述となるが、実際にはRESTで連携しているようになる。また、これをAPI呼び出しでなく、Delegateで行うと、ある種のprocedureの自動転送が行えるようになり、意味論的にもうまくつながり、実装スピードが速くなる事が予想される。

このRESTDelegateやREST APIでの繋がりをRESTfulオブジェクトと呼ぶことにする。

明示的にMicro Serviceとは言ってないが、その考え方もRESTfulオブジェクトの中に取り入れて設計/実装すると仕様変更に対してロバストなシステムになると予想される。

この考え方を推し進めると、小さいサブシステムを作りRESTFulにDelegateやAPIでつなげてしまえば有機的に、順次、政策変更やビジネス要件変更に耐えられるロバストなシステムを作れるのではないかと予想する。

## なぜ、オペレーションなのか？オペレーションと労働環境
では、なぜオペレーションを念頭においたフレームワークなのであろうか？まず、オペレーションとは何かを定義する。事業会社、例えば、お菓子会社ではお菓子の原料の受発注業務が存在するであろう。受発注は単純に取引先に発注のオーダーをかけるだけでなく、その前後に業務プロセスが存在する。Aさんが、何となにをして、Bさんが何となにをする、と言った具合である。そして、発注をシステムやなんらかの通信手段によっておこない。取引先から帰ってきたら、また、それを処理する業務プロセスが存在する。これを一般にオペレーションと呼ぶ。

このような業務プロセスはプロセス図にすると例えば、なんらかの発注周りで、場合によってはA4で3 - 5ページに及ぶこともある。

オペレーションは一般に女性が担当する事が多い。日本の事業会社の職場ではよく言われるのが、有給が取りにくい、早退しにくいといったことである。早退しにくいと何が問題なのであろうか？ここで、既婚女性に問題を絞る事にする。一般に小さい子供は風邪を引きやすい。したがって、なんらかの自体が子供におきたら、女性社員は早退するか、有給をとりたいであろう。しかし、早退しにくい。なぜ、早退しにくいのであろうか？問題はオペレーションの組み方と人員配置にある。営業利益をマックスに高めるために、人員を最小限にしぼり、ガチガチのオペレーションを組むと、一人が抜けただけで、オペレーション、すなわち部なり課なりの仕事がまわらなくなる。なので、周りに迷惑がかかるという理由で早退などをしにくくなる。

では、営業利益を多少、例えば、0.5%くらい低くして、人員を多少増やしたらどうなるのであろう？経営側からみると、営業利益の0.5%くらいなら、落としてもいい、と言うことにだろう。従業員から見ると、オペレーションに余裕ができるので、有給/早退などをしやすくなる。システムから見ると、もちろん、対応するオペレーションの業務プロセスやシステムに最適化をかける。このように、オペレーション最適化と対応するシステム構築、経営の*KPI設計*を一体になって行えば、経営側も従業員もみな、幸福度関数の取る値が高くなると予測される。

ここに書くまでもなく、日本労働環境は狂っている。毎日のように残業をし、家に帰るのは遅い。だが、GDPは中国の後塵を廃し3位。一人あたりGDPはスペインの1.x倍程度。スペインより上であるが、ぶっちぎりではない（なんと言っても、スペインはシエスタの国だ）。これから、高度成長期のように経済が伸びていく予兆もない。言葉を変えれば、一人あたりGDP、あるいは、時間あたり労働生産性は低く、なんのために、馬車馬のように働いているのか、全く分からない。非正規社員は50%を超え、報酬も少ない。大企業の事業部長で1500万円、取締役でさえ年収3000万円しかもらえず、誰も得をしない世界。

では、どうすれば、労働時間を減らせるのであろうか？筆者はキードライバーの一つはオペレーション最適化にあると思っている。システム開発などでは、比較的、創造性が高い仕事でその人自身の能力次第で一日3 - 4時間の労働で十分な場合が多々ある。しかし、一般従業員の大半はそういうクリエイティブ系の仕事をしているのではなく、オペレーションを回しているのであろう。したがって、そのオペレーションを分析し、最適化を常にかけ、システムに落とせば、労働生産性は高くなると予想する。

実際、筆者が以前所属していた企業では、オペレーション最適化の結果、19時定時で23時までの残業が当たり前だったのが、労働時間が20時くらいまでに抑制された。この経験から、普通にしていれば、8時間労働、もっとうまくやれば、6 - 7時間の労働時間まで同様なGDPで持っていけるのではないかと予想する。

## 元々のコードベースに対する説明

## コードのライセンスとなぜ、このコードが作られたかについて

以下、ライセンスについての注釈となる。また、このコードはある企業への採用試験への提出物をベースにしている。しかし、

1. このコードのライセンスは当初、すなわち、上記のある企業への提出前からBSDライセンスで筆者が抑えていて、かつ、いかなる第三者との契約に関する制限もなく、また、いかなる種類の仕事上の成果物では無い事を念頭に、公開するのは自身の自由という事をお断りしておく。

2. また、対象企業特有のファイルは全て消してある。したがって、ある程度commit logなどにオリジナルのものとずれが生じている可能性がある事をお断りしておく（OldChangedLog.txt参照の事）。

3. そもそも論、コードやライブラリの設計は筆者の考え方に基づくものであり、このフレームワークに考え方の源流は少なくとも、2012年時点までに遡ることができる。ライセンスなど法的な事を考えても公開は合法であると考えるが、先に述べたように、どこに迷惑をかけるわけでもない、かつ、金銭が関わるか否かに関係なく、仕事上の成果物でないと考える。それを言い出すと、プログラマはいかなるコードもいかなるライセンス種別は別として、公開できないと考える。また、先方に断りを入れてある。

別の視点で述べると多少トリッキーな主張であるという見方があるであろう事は認めるが、IT業界、特にWeb業界がGPLやBSD Licenseの成果物やDesign Patternなどの過去の成果物あるいは古典、そして、経験の結果得られたプログラマの暗黙知に頼っている事を考えると、この主張は妥当ではないかと考える。

筆者のライセンスに対する考え方は以下のドキュメントに記述してある：

https://docs.google.com/document/d/1DOS8hw5K8k4iM7XhG2_RSwjhyOC2Yi8pRXynIhCYF7s/edit

以上でライセンスに対する注釈を終わる。以下、本リポジトリに含まれるプログラムの*昔の*解説となる(フルバージョンのフレームワークではなく、発端となったシステムの解説)。

本論

1. 本ディレクトリに含まれるプログラムの設計とマズい点についての解説（初期バージョン。現バージョンはフルスタックのフレームワークになっており、以下は小さい機能についてだけである）

本プログラムではある一定フォーマットのRSSを処理して、適切なデータ処理をする事を目的とする。具体的には単なる文字列の検索/置換の問題となる。しかしながら、出入力の柔軟性や元のRSSデータに対するある程度の柔軟性を保つように、単なる書き捨てのスクリプトでなく、ある程度プラガブルに作った。

しかし、いくつか問題点がある
1. PHPの既存のXMLパーサーに対する誤解。ここはXMLパーサーがどんな処理をしても、完全に一般的な仕様を満たせないので、本来なら、パーサーごと、自作するべきであった。しかし、この時は時間の制約のため、不完全な仕様で終わった。具体的には柔軟性を保つために、ある程度アダプターを作ったが、元ライブラリの制限上、上記のような結果となる。また、アダプターのクラスのI/Fもある程度、元のライブラリに引きずられ、抽象化の度合いが低い。

2. また、標準エラー出力や標準出力もアダプターを作り抽象化の度合いを上げ、ダイナミックに出力を変更できるようにする予定であったが、時間の制約上、普通の処理で終わらせた。ただし、OutputHandlerなどで、高次の抽象化はしてある。

以下、プログラムの説明と、より詳細な設計について述べる

2. プログラムについて

プログラムとして、以下のディレクトリに格納。bin以下のphpファイルを実行の事。
bin/, lib/, unit_test/, util/

以下のようなコマンドをbin/ディレクトリで実行すると当該問題の出力結果を得る
php RSSesConverterBatch.php  Foo Replaced 

・実装環境
言語：PHP5.4.16
フレームワーク：特になし

3. クラス構成
以下にクラス構成図を示す。基本的には全てインスタンスを表す。例えば、RSSはRSSクラスのインスタンスを意味する。

・RSS周りの処理クラスとインスタンス関係図（だいたい）
RSSesConverterBatch <=inherit= BaseBatch =manipulate=> BaseErrorHandler
↓ manipulate
RSSesConverter =manipulate=> BaseOutputHandler
↓ manipulate
RSS =has a=> RSSElement =has a=> DOMElement
↓ has a
DOMDocument

入力、出力の変更は基本的にobjecctのインジェクションを行う事によって、柔軟に変更できるように設計している。より柔軟性を保つのであれば、Factoryなどを作ることになると思う。

BaseBatch: いわゆるmain関数（static void main()的な）ものを定義するとこ。エラーハンドリングなどはBaseBatchで定義され、このサブクラスで実際の処理を書く。

BaseOutputHandler => 出力関係。テキストファイルに保存するなどの要求が出たら、このサブクラスを作り、入れ替えればいい。
BaseErrorHandler => エラーハンドリング関係。ほぼ、エラーも含めて、例外で処理するにょうになっているはず。簡易フレームワークになっているので、エラーハンドリングの方法を変えたければBaseErrorHandlerを変更すればよい。Factoryなどを作ればダイナミックに変更も可能。

入力RSSを複数にするのは可能。RSSesConverterを参照。基本的にはRSSクラスのインスタンスをRSSesConveterでいじっているので、多少コードを変更すればいい。ここも変換方法をプラガブルに変更可能のようにできるかと思う。（単に同一インターフェースのクラスを作ればいい）

has a、manipualteともにあるクラスのインスタンスが対象クラスのインスタンスをインスタンス変数に保持しているという関係性については同じだが、has aは基本的にdelegate的な関係を示し、manipulateはどちらかというと、Contrller/Action内でmodelを操作する関係性に近い。

しかし、has a、manipulate両者とも、object compositionが継承よりも有利あるいは扱いやすく柔軟性に富むのでは、という発想に基づいて使用されている。意味的な相違は上述の通りである

4. 基本ライブラリ（だいたいの説明）
Env(環境情報あるいはグローバルで扱われがちなオブジェクトを保持する。ただし、グローバルアクセスはありえない、という前提である)
Util（いわゆるワンライナー的なユーティリティ関数の集合。staticで実装。クラスは単なる名前空間として使っている）
UException（例外のラッパー）
BaseErrorHandler（エラー処理に責務を負うクラス。場合によってはstderr、場合によってはファイルに書き出す）
BaseUnitTest（簡易な単体テストのための基底クラス。method名によって、どのテストケースを処理するのかのみを実装している。assertなどは特に実装していない）


5. 実装方針と説明
node valueなどの問題は残る。（これは内部で使っているライブラリの仕様上、不可避だと考える。しかし、全て仕様を満たしつつ、処理も適切にするなら、単にhtml special chars decodeの結果をstr_replace()すればいい。別にどっちでもいい）

今回はPHPのXMLパーサーの仕様の勘違いと当該RSSを一般化しすぎて考えたので、オーバーエンジニアリングなコードとライブラリとなった。

今回はXMLを再帰的に処理して（XMLが木構図のため。この考えはRSSConverterのコードに見て取れる。提出のbatchでは未使用）、全てのinner html的なものを置換する予定であった。

仕様を完全に満たすのは簡易な実装（str_replaceを内部のHTMLにかける）であるが、より柔軟性あるいは正確性を求めるべきと考え、上記実装を試みた。しかし、上述のとおり、内部で使っているPHPのDOMDocument関連の仕様の制限上、完全に仕様を満たすのは難しいという見解である

前述の正確性とは例えば、検索/置換体調の文字列がタグに含まれる場合、単なるstr_replaceでは正確には実行できない。

したがって、今回の言語環境あるいは知っているライブラリの制限を考えるならば、自前でXML/HTMLパーサーを書くべきだったかもしれないが、それはさすがに予期せず、今回はこういう結果になった。

プロダクション環境で実際に使用するコードであるならば、上述のタグ/本文での検索対象文字列の問題が仮に対象文章(rssあるいはHTML)にないと仮定するなら、単純なstr_replaceの実装で行う。

しかし、そうでなく、かつ、ある程度時間が取れるならば、簡易なHTMLあるいはXMLのパーサーのサブセットを作成する可能性が高い。しかし、あくまでも時間あるいは人的コストとそれによって、サービスに加わる価値などを総合的に判断しての事となるかと思う。

しかしながら、検索/置換対象が単なるHTMLなので、その場合は上記の考えは単なる杞憂で仕様の理解を間違っているという事もできる。しかしながら、内容が任意のXMLであれば、上記の仮定は正しい。

6. 参考文献 (URL）
http://qiita.com/mpyw/items/c0312271819baee09132
-- DOMと文字列操作の例があるが、この例をそのまま使用するとネストしたタグの内部のテキストをきちんと検索/置換するのは難しい気がする。しかしながら、それは筆者の認識不足の可能性もある。

http://php.net/manual/ja/class.domtext.php
-- NodeTextとかでDOM node内部の検索置換をうまくやれるっぽいサンプルコードがあるが、既存のテキストからDOMDocumentを作成して、そこからDOM nodeあるいはDOM Elementを取り出した場合はおそらく、このURLのサンプルコードは動かないのでは？あるいは筆者の見識不足かもしれない。

以上
